# Ember.View

## Questions

* can i override autogenerated views that go with a template like i can with routes/controllers etc.?

## General

* Views are arranged in a heirarchy
* "View heirarchies are usually created by evaluating a handlebars template"
    * => a single template can create multiple views
    * views are automagically created to be the logic that backs a template
    * a template is like a blueprint for creating views
    * the template will automatically create views for you
    * templates are kind of a declaratively way to create views
* Every handlebars expression e.g. {{foo}}
* You can change the view heirarchy at run-time using `Ember.ContainerView`

* views contain child views in the same way that DOM nodes contain their children

Templates:Views is a many:many mapping

* A view can use different templates
* A template can generate multiple views

## How does ember handle DOM events?

1. It delegates everything to the top level ember app element (usually `<body>`)
    * ember registers **one** event handler for each type of event so you never
      need to change them over the lifetime of your app
    * so you don't have to delegate/undelegate events when you add/remove child view 
2. it finds the view nearest to the event origin that has a handler for the
   event and gives the event to it.

## Ember view rendering timeline

application calls `append` or `appendTo` on the view
    this causes the view to be scheduled to be rendered (allowing binding sync to happen first)
Ember creates a RenderBuffer and gives it to the view and tells it to append it's content to it
    If the view needs to create child views, it will create RenderBuffers for them * child RenderBuffers have a link back to the parent RenderBuffer

By the time that the top levewl view has finished rendering, Ember has two trees
in memory

1. a tree of View objects
2. a tree of RenderBuffer objects
o
Now Ember walks down the tree of RenderBuffers, converting them to strings

A RenderBuffer also encapsulates an element's tag name and attributes which
makes it possible for the render process to modify them even **after** it's
children have been rendered. This is important because bindings in the children
could affect them

Ember then uses jQUery to convert the string into an element


## Virtual views

* `{{if}}` and `{{with}}` create virtual views * they are for Ember's internal bookeeping only
* they are "virtual" because they don't appear in the `parentView` or `childView` properties
* you can get at them using `this.get('_parentView')` or `this.get('_childViews')` but doing so is bad form

## Ember.ContainerView

* exposes an array of child view instances
* contains no text - is made up entirely of child views
* is a way to programmatically build up a view heirarchy (nested arrays of views)
* has the properties
    * a writable `childViews` array
    * a `currentView` - when set it adds the view to the `childViews` array and
      removes the old value of `currentView` from the `childViews` array - this
      eems odd???


View properties

```
attributeBindings: [] // a list of view properties to apply as attributes of the containing element
element: // returns the current DOM element for the view
isVisible: // is this view currently visible in the DOM
nearestOfType: // return the view object that is an instance of the provided class/mixin
                // this.nearestOfType(App.SomeKindOfView)
                
views: // a reference to the global views hash ???
classNames: []
classNameBindings: [] // a list of view properties to apply as class names to the containing element
tagName: 'div' // a string representing the HTML tag that will enclose the view
template: // function that gets a context and returns a HTML string
templateName: // the name of a template in Ember[TEMPLATES]
defaultTemplate: // function takes a context and returns HTML string, 
templateVariables:  // an object containing the variables that were in scope when
                    // the view was rendered

controller: // reference to an object that will be used as a context
            // if a view does not have an explicity controller property it will inherit the propertiy from it's parent
context: // reference to an object from which the template should access properties
parentView: a reference to the "parent" view //if neither controller nor context are set, then the parentView's context will be used

layout: // a function that takes a context and returns HTML string.
// the template you use for layout must have exactly one {{yield}} in it 
        // it will wrap the output of 'template' (or 'templateName')
layoutName: // string representing the name of a layout template

// * NB events in eventManager take precedence over events in child views that
//   are defined directly in that view
eventManager {
    // event handlers
    // * handlers in here swallow events so that child views will not see them.
    //   How does this work?
    click: function(jQueryEvent, view) {
        // stop propagation with 
        jQueryEvent.stopPropagation()
        // or
        return false; // same as jquery
    }
    mouseEnter: function(jQueryEvent, view) { }
}

// event handlers
// **************
// any handlers defined in eventManager will override these
// * these handlers get different params than the handlers in eventManager
click: function(jQueryEvent) { }
mouseEnter: function(jQueryEvent) { }

```


Q: what makes a "parent" view?

If your template contains `{{view App.SomeView}}` then that view will be
rendered as a child view into the place where it appears in the template

One advantage of not defining events in eventManager is that you can call them
from other parts of your view easily

## View Methods

render()
    createElement() // called recursively by render()
// lifecycle hooks
didInsertElement()
willClearRender()

rerender() // redo the rendering process

$ // jquery object for this view's element e.g. myView.$('li') // find all <li> tags in current view


Ember.CollectionView.extend() // ???

Within a view `this.get('content')` will get you the context object (the object
that has properties you need)

Make a view by 
```
Ember.View.extend({});
```


```
// A pattern for running code after your view has been rendered
// * Just before the view is about to be rendered, you add some code ot the 'afterRender' queue which will be run once just afterwards
App.SomeView = Em.View.extend({
  template: '{{template "lots_of_images"}}',
  didInsertElement: function(){
    // This callback runs before lots_of_images has rendered.
    this.scheduleMasonry();
  },
  scheduleMasonry: (function(){
    // scheduleOnce debounces applyMasonry to only run once per
    // runloop. scheduleMasonry is called on didInsertElement, and
    // whenever controller.images changes.
    Ember.run.scheduleOnce('afterRender', this, this.applyMasonry);
  }).observes('controller.images.@each'),
  applyMasonry: function(){
    // http://masonry.desandro.com/index.html
    this.$('.container').masonry({
      itemSelector: '.item',
      columnWidth: 150
    });
  }
});

## Getting access to parents and children

Within a view
```
this.get('parentView'); // our parent
this.get('childViews'); // array of child view objects
```

Views have lifecycle hooks that you can attach handlers to

* willInsertElement
* didInsertElement
* willDestroyElement
* willClearRender
* becomeVisible
* becameHidden

You can register listeners to these events from outside the view (if you have a
reference to it)
```
view.on('willClearRender', function () {
});
```
This works because views use Ember's evented stuff

Ember comes wiht a bunch of events already defined incl. the drag & drop ones


The only way to craete a view hierarchy using templates is with the {{view}} helper

* Handlebars templates have a notion of the 'current view' (the view that is
closest) 
* it is accessible through the `{{view}}` helper e.g.
    {{view.someProp}}
* even though the handlebars context is the controller, {{view}} still points at
  the view

* Handlebars contexts can inherit properties from their parent contexts !!!
* Helpers can also create variables e.g. `{{#each users as user` creates `user` in the enclosed context
